Apprentissage :
	☐ Recuperer les inputs -> W A S D pour les deplacements, escape pour sortir du jeu, ctl + c pour sortir du jeu
	☐ 	|-> Hooks
	☐ Comment charger les textures sur les bons emplacements de la map
	☐ Gerer les possibilites de deplacement -> si un mur, impossible de se deplacer
	☐ Compter les differents collectibles pris par le joueur
	☐ Modifier la texture d'une case / supperposer des textures

Fonctionnement du programme:
	✔ Checker si la map est valide
	✔ 	|->	Regarder si la map est un rectangle entoure de murs 				|| Faire une fonction check_map(char **map);
	✔ 	|-> Regarder le nombre d'elements dans la map
	✔ 		|-> 1 player
	✔ 		|-> 1 exit
	✔ 		|-> N collectibles
	✔ 		|-> N ground
	✔ 		|-> N wall
	✔ 		|-> pas d'autres caracteres
	✔ 	|->	Regarder s'il existe un chemin valide (le joueur peut acceder a tous les collectibles et a la sortie)	|| Faire une fonction check_path(char **map);
	✔ 		|-> Faire une copie de la map originelle, avec les murs, le caractere a trouver et le player puis DFS dedans avant de free la map
	☐ 	|->	La map doit tenir dans l'ecran donc diviser la taille par 32 et regarde si ca rentre
	✔ Charger la MLX 
	✔ Ouvrir une fenetre et stocker le pointeur sur cette fenetre
	☐ Charger les textures en fonction de la map
	☐ 	|->	Free toutes les textures chargees si une ne se charge pas correctement et arreter le programme
	☐ Modifier la texture d'une case quand le joueur se deplace
	☐ Compter le nombre de collectibles pris par le joueurs -> Quand on arrive sur une case de collectible on fait + 1 et on modifie la value dans la matrice
	☐  

	
	To change:
		✔ Rajouter le free(map) dans la fonction ft_error();
		✔ map_alloc : faire en sorte que map[i] et line ne soient pas a la meme adresse pour ne pas avoir de probleme
		☐ Rajouter le fait que la map n'est pas valide si il n'y a pas un collectible
		Ressources :
			https://chat.openai.com/share/183d3029-a806-418f-82f3-7bb8722e4b75
			
			
Notes :
	Lenght	= nombre de colonnes + 1
	Width 	= nombre de lignes + 1
	
	W = wall
	E = exit
	G = ground
	P = player
	C = collectible
	
BONUS_PART :
	Map Generator :
		☐ Objectif : Generer de grandes maps automatiquement de maniere procedurale
		☐ 	|-> Generation d'une map avec le sol, un donjon sous le sol et une partie dans les airs.
		☐ 	|-> La map doit pouvoir s'afficher sur l'ecran ou alors se deplacer en gardant le joueur au centre pour une agreabilite de jeu
		☐ 	|-> La map doit etre traitable par so_long (rectangle, murs, collectibles, ...)
		☐ 	|-> Map sur la verticalite : Gravite + escalier + ...
		☐ 		|-> Travailler les deplacement pour que le joueur "Monte l'escalier" 
		☐ Gere les dynamiques lights
		☐ 	|-> Si un mur n'est pas en bordure de caverne, le rendre plus sombre
		☐ 	|-> Les espaces vides proches de zones de lumieres sont plus eclaires, et l'intensite diminue en s'eloignant de la torche
		☐ Fluidite du decors :
		☐	|-> Faire des murs penches ? Si je capte un "escalier" de murs, je peux faire une pente
		--------
		☐ Rajouter des structures sur lesquelles mes collectibles sont poses (donjons, ...)
		☐ 	|-> Mettre des supports regulierement pour soutenir les structures si elles sont en l'air
		☐ 	|-> Mettre un acces aux differentes parties de la map
	Gameplay :
		☐ Possibilite d'avoir un inventaire, et des statistiques
		☐ 	|-> Inventaire limite -> On peut afficher l'inventaire du joueur en appuyant sur une touche definie
		☐ 	|-> Possibilite de casser et poser les blocs -> Changement de la matrice de points en fond (matrice 3 dimensions ?)
